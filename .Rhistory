paper.keyword.type.desc <- lapply(ego.nets, get.keyword.types)
# collapse from list into data frame
paper.keyword.type.desc <- bind_rows(paper.keyword.type.desc)
# add to main data
data.bioeth.1 <- bind_cols(data.bioeth.1, paper.keyword.type.desc)
# remove now unnecessary object
rm(paper.keyword.type.desc)
####
### create the non-keyword-related variables
###
### paper level
# number of authors
data.bioeth.1 <- data.bioeth.1 %>%
mutate(num.authors = str_count(authors, ";") + 1)
# number of institutions
data.bioeth.1 <- data.bioeth.1 %>%
mutate(num.addresses = str_count(author.address, "\\["))
# a [] pair introduces each unique address
# number of cited references
data.bioeth.1 <- data.bioeth.1 %>%
mutate(num.refs = str_count(cited.refs, ";") + 1)
names(data.bioeth.1)
names(data.bioeth)
journal_names <- unique(data.bioeth$pub.name)
dim(journal_names)
length(journal_names)
head(journal_names, 20)
journal_names_counted <- count(data.bioeth$pub.name)
library(dplyr)
library(tidytext)
journal_names_counted <- data.bioeth %>% count(pub.name, sort = TRUE)
head(journal_names_counted)
getwd()
setwd("/Users/brandonsepulvado/Documents/bioethics-networks")
write.csv(journal_names_counted, file = "journal_names_counted.csv")
library(dplyr)
library(plyr)
library(lubridate)
library(forecast)
# import resulting objects (if more than 24 hour gap, df becomes NULL)
sleep_filtered <- readRDS("/afs/crc.nd.edu/user/b/bsepulva/Private/sleep_filtered.rds")
steps_filtered <- readRDS("/afs/crc.nd.edu/user/b/bsepulva/Private/steps_filtered.rds")
sleep_filtered <- readRDS("sleep_filtered.rds")
steps_filtered <- readRDS("steps_filtered.rds")
# remove NULL entries
sleep_filtered <- plyr::compact(sleep_filtered)
steps_filtered <- plyr::compact(steps_filtered)
# plot distribution of element nrow()s
sleep_nrow <- sapply(sleep_filtered, nrow)
steps_nrow <- sapply(steps_filtered, nrow)
# remove elements with fewer than 10 observations
sleep_filtered <- lapply(sleep_filtered, function(x){
if (nrow(x) < 10) {
return(NULL)
} else {
return(x)
}
})
# remove NULL elements
sleep_filtered <- plyr::compact(sleep_filtered) # now 10820 elements
length(sleep_filtered)
auto_arima_results <- lapply(sleep_filtered, function(x){
x$diff %>%
forecast::auto.arima()
})
# remove elements with fewer than 10 observations
sleep_filtered <- mclapply(sleep_filtered, function(x){
if (nrow(x) < 10) {
return(NULL)
} else {
return(x)
}
}, mc.cores = getOption("mc.cores", 4L))
sleep_filtered <- parallel::mclapply(sleep_filtered, function(x){
if (nrow(x) < 10) {
return(NULL)
} else {
return(x)
}
}, mc.cores = getOption("mc.cores", 4L))
# remove elements with fewer than 10 observations
sleep_filtered <- mclapply(sleep_filtered, function(x){
if (nrow(x) < 10) {
return(NULL)
} else {
return(x)
}
})
# remove NULL elements
sleep_filtered <- plyr::compact(sleep_filtered) # now 10820 elements
auto_arima_results <- parallel::mclapply(sleep_filtered, function(x){
x$diff %>%
forecast::auto.arima()
}, mc.cores = getOption("mc.cores", 4L))
auto_arima_results[[1]]
glimpse(auto_arima_results[[1]])
class(auto_arima_results[[1]]$arma)
auto_arima_results[[1]]$arma
as_tibble(auto_arima_results[[1]]$arma)
t(as_tibble(auto_arima_results[[1]]$arma))
t(auto_arima_results[[1]]$arma)
as_tibble(t(auto_arima_results[[1]]$arma))
arma_output <- parallel::mclapply(auto_arima_results,
function(x){
arma <- x$arma %>%
t() %>%
as_tibble()
return(arma)
}, mc.cores = getOption("mc.cores", 4L))
# collapse arma_output
arma_output <- bind_rows(arma_output)
arma_output
sum(arma_output$V1)
sum(arma_output$V2)
sum(arma_output$V3)
sum(arma_output$V4)
sum(arma_output$V5)
sum(arma_output$V6)
sum(arma_output$V7)
max(arma_output$V1)
max(arma_output$V2)
max(arma_output$V4)
max(arma_output$V5)
max(arma_output$V6)
hist(arma_output$V1)
hist(arma_output$V2)
install.packages("factoextra")
library(factoextra)
fviz_nbclust(arma_output,
FUNcluster = kmeans,
method = c("silhouette", "wss", "gap_stat"))
fviz_nbclust(arma_output,
FUNcluster = kmeans,
method = "silhouette")
fviz_nbclust(arma_output,
FUNcluster = kmeans,
method = "silhouette")
# via total within sum of squares
fviz_nbclust(arma_output,
FUNcluster = kmeans,
method = "wss")
# via gap stat
fviz_nbclust(arma_output,
FUNcluster = kmeans,
method = "gap_stat")
set.seed(1234)
kmeans_7 <- kmeans(arma_output, 7)
kmeans_7
fviz_cluster(kmeans_7, data = arma_output,
ellipse.type = "convex",
palette = "jco",
ggtheme = theme_minimal())
# Visualize
fviz_cluster(kmeans_7,
ggtheme = theme_minimal())
# Visualize
fviz_cluster(kmeans_7, data = arma_output,
ggtheme = theme_minimal())
arma_output_filtered <- arma_output %>%
select(V1, V2, V5, V6)
# via average silhouette width
fviz_nbclust(arma_output_filtered,
FUNcluster = kmeans,
method = "silhouette") # 7
kmeans_7 <- kmeans(arma_output_filtered, 7)
# Visualize
fviz_cluster(kmeans_7, data = arma_output_filtered,
ggtheme = theme_minimal())
set.seed(1234)
kmeans_7 <- kmeans(arma_output_filtered, 7)
# Visualize
fviz_cluster(kmeans_7, data = arma_output_filtered,
ggtheme = theme_minimal())
var(arma_output_filtered$V1)
var(arma_output_filtered$V2)
var(arma_output_filtered$V5)
var(arma_output_filtered$V6)
# remove V5 because variance == 0
arma_output_filtered <- arma_output_filtered %>%
select(-V5)
# via average silhouette width
fviz_nbclust(arma_output_filtered,
FUNcluster = kmeans,
method = "silhouette") # 7
set.seed(1234)
kmeans_7 <- kmeans(arma_output_filtered, 7)
# Visualize
fviz_cluster(kmeans_7, data = arma_output_filtered,
ggtheme = theme_minimal())
set.seed(1234)
kmeans_7 <- kmeans(arma_output_filtered,
centers = 7,
nstart = 25)
# Visualize
fviz_cluster(kmeans_7, data = arma_output_filtered,
ggtheme = theme_minimal())
library(ggplot2)
library(dplyr)
library(lubridate)
# load sleep data
dyad_sleep_diffs <- readRDS("dyad_sleep_diffs.rds")
# load steps data
dyad_steps_diffs <- readRDS("dyad_steps_diffs.rds")
# how many dyads have missing data, meaning both in study at same time
# but one person (at least) has NA for day on given measure
missing_steps_days <- sapply(dyad_steps_diffs, function(x) sum(is.na(x['diff'])))
missing_sleep_days <- sapply(dyad_sleep_diffs, function(x) sum(is.na(x['diff'])))
# get proportion of dyad's common dates with missing data
missing_steps_prop <- sapply(dyad_steps_diffs, function(x) sum(is.na(x['diff'])) / nrow(x))
missing_sleep_prop <- sapply(dyad_sleep_diffs, function(x) sum(is.na(x['diff'])) / nrow(x))
# make tibble to be able to facet histogram
steps_miss_prop_t <- as_tibble(missing_steps_prop) %>%
rename(proportion = value) %>%
mutate(activity = "steps")
missing_steps_prop
sleep_nrow_dist <- sleep_nrow %>%
as_tibble() %>%
ggplot(aes(x = value)) +
geom_density(show.legend = FALSE) +
#coord_cartesian(xlim=c(1, 100)) +
labs(title = "Distribution of Number of Observations for Dyads",
subtitle = "Final Data before Time Series Models",
x = "Number of Observations",
y = "Density") +
theme_minimal()
sleep_nrow_dist <- sleep_nrow %>%
as_tibble() %>%
ggplot(aes(x = value)) +
geom_density(show.legend = FALSE) +
#coord_cartesian(xlim=c(1, 100)) +
labs(title = "Distribution of Number of Observations for Dyads",
subtitle = "Final Data before Time Series Models",
x = "Number of Observations",
y = "Density") +
theme_minimal()
sleep_nrow_dist
missing_steps_days <- sapply(dyad_steps_diffs, function(x) sum(is.na(x['diff'])))
missing_sleep_days <- sapply(dyad_sleep_diffs, function(x) sum(is.na(x['diff'])))
# get proportion of dyad's common dates with missing data
missing_steps_prop <- sapply(dyad_steps_diffs, function(x) sum(is.na(x['diff'])) / nrow(x))
missing_sleep_prop <- sapply(dyad_sleep_diffs, function(x) sum(is.na(x['diff'])) / nrow(x))
steps_miss_prop_t <- as_tibble(missing_steps_prop) %>%
rename(proportion = value) %>%
mutate(activity = "steps")
library(dplyr)
steps_miss_prop_t <- as_tibble(missing_steps_prop) %>%
rename(proportion = value) %>%
mutate(activity = "steps")
as_tibble(missing_steps_prop)
steps_miss_prop_t <- as_tibble(missing_steps_prop)
steps_miss_prop_t <- steps_miss_prop_t %>%
rename(proportion = value) %>%
mutate(activity = "steps")
library(ggplot2)
library(dplyr)
library(lubridate)
# load sleep data
dyad_sleep_diffs <- readRDS("dyad_sleep_diffs.rds")
# load steps data
dyad_steps_diffs <- readRDS("dyad_steps_diffs.rds")
# verify object classes
class(dyad_sleep_diffs)
class(dyad_steps_diffs)
# number of elements in each
length(dyad_sleep_diffs)
length(dyad_steps_diffs)
head(dyad_sleep_diffs[[1]], 10)
# count how many were in study at same time
same_time_steps <- sum(sapply(dyad_steps_diffs,
function(x) nrow(x) > 0))
# should be the same
same_time_sleep <- sum(sapply(dyad_sleep_diffs,
function(x) nrow(x) > 0))
same_time_sleep
same_time_steps
# how many dyads have missing data, meaning both in study at same time
# but one person (at least) has NA for day on given measure
missing_steps_days <- sapply(dyad_steps_diffs, function(x) sum(is.na(x['diff'])))
missing_sleep_days <- sapply(dyad_sleep_diffs, function(x) sum(is.na(x['diff'])))
# get proportion of dyad's common dates with missing data
missing_steps_prop <- sapply(dyad_steps_diffs, function(x) sum(is.na(x['diff'])) / nrow(x))
missing_sleep_prop <- sapply(dyad_sleep_diffs, function(x) sum(is.na(x['diff'])) / nrow(x))
# make tibble to be able to facet histogram
steps_miss_prop_t <- as_tibble(missing_steps_prop) %>%
rename(proportion = value) %>%
mutate(activity = "steps")
sleep_miss_prop_t <- as_tibble(missing_sleep_prop) %>%
rename(proportion = value) %>%
mutate(activity = "sleep")
missing_prop_combined <- bind_rows(steps_miss_prop_t,
sleep_miss_prop_t)
# get mean for missing proportion types for histograms below
mean_steps <- mean(steps_miss_prop_t$proportion, na.rm = TRUE)
mean_sleep <- mean(sleep_miss_prop_t$proportion, na.rm = TRUE)
# get median for missing proportion types
# get mean for missing proportion types for histograms below
median_steps <- median(steps_miss_prop_t$proportion, na.rm = TRUE)
median_sleep <- median(sleep_miss_prop_t$proportion, na.rm = TRUE)
# plot histogram faceted
missing_prop_combined %>%
ggplot(aes(x = proportion, fill = as.factor(activity))) +
geom_histogram(alpha = 0.5) +
facet_wrap(~as.factor(activity)) +
labs(title = "Proportion of day data missing for each dyad",
x = "Proportion",
y = "Count") +
scale_fill_discrete(name = "Type of activity") +
geom_vline(data=filter(missing_prop_combined, as.factor(activity)=="steps"),
aes(xintercept=mean_steps), linetype = "dashed", colour="black") +
geom_vline(data=filter(missing_prop_combined, as.factor(activity)=="sleep"),
aes(xintercept=mean_sleep), linetype = "dashed", colour="black") +
geom_vline(data=filter(missing_prop_combined, as.factor(activity)=="steps"),
aes(xintercept=median_steps), linetype = "solid", colour="black") +
geom_vline(data=filter(missing_prop_combined, as.factor(activity)=="sleep"),
aes(xintercept=median_sleep), linetype = "solid", colour="black")
class(dyad)
class(dyad_sleep_diffs)
dyad_sleep_diffs[[1]]
# get number of non_missing days for dyads
nonmissing_steps_days <- sapply(dyad_steps_diffs,
function(x) sum(!is.na(x['diff'])))
nonmissing_sleep_days <- sapply(dyad_sleep_diffs,
function(x) sum(!is.na(x['diff'])))
# make tibble to be able to facet histogram
steps_nonmiss_t <- as_tibble(nonmissing_steps_days) %>%
rename(n_days = value) %>%
mutate(activity = "steps")
sleep_nonmiss_t <- as_tibble(nonmissing_sleep_days) %>%
rename(n_days = value) %>%
mutate(activity = "sleep")
nonmissing_combined <- bind_rows(steps_nonmiss_t,
sleep_nonmiss_t)
# get mean for missing proportion types for histograms below
mean_steps <- mean(steps_nonmiss_t$n_days, na.rm = TRUE)
mean_sleep <- mean(sleep_nonmiss_t$n_days, na.rm = TRUE)
# get median for missing proportion types
# get mean for missing proportion types for histograms below
median_steps <- median(steps_nonmiss_t$n_days, na.rm = TRUE)
median_sleep <- median(sleep_nonmiss_t$n_days, na.rm = TRUE)
# plot histogram faceted
nonmissing_combined %>%
ggplot(aes(x = n_days, fill = as.factor(activity))) +
geom_histogram(alpha = 0.5) +
facet_wrap(~as.factor(activity)) +
labs(title = "Distribution of non-missing days per dyad",
x = "Number of Days",
y = "Count") +
scale_fill_discrete(name = "Type of activity") +
geom_vline(data=filter(nonmissing_combined, as.factor(activity)=="steps"),
aes(xintercept=mean_steps), linetype = "dashed", colour="black") +
geom_vline(data=filter(nonmissing_combined, as.factor(activity)=="sleep"),
aes(xintercept=mean_sleep), linetype = "dashed", colour="black") +
geom_vline(data=filter(nonmissing_combined, as.factor(activity)=="steps"),
aes(xintercept=median_steps), linetype = "solid", colour="black") +
geom_vline(data=filter(nonmissing_combined, as.factor(activity)=="sleep"),
aes(xintercept=median_sleep), linetype = "solid", colour="black")
# function to get interval vector
get_date_differences <- function(data, format = "day"){
#date_var <- enquo(date_var)
temp <- data %>%
filter(!is.na(diff)) %>%
select(datadate)
temp <- ymd(temp$datadate)
diffs <- temp %>%
int_diff() %>%
as.duration() %>%
as.numeric()
if(format == "day") {
return(diffs / 86400)
} else if (format == "seconds") {
return(diffs)
} else {
stop("You have chosen an unsupported date format!")
}
}
###
# this bit of code only needs to be run once
# apply function to sleep data
#date_diffs_sleep <- lapply(dyad_sleep_diffs, get_date_differences)
#date_diffs_sleep <- parallel::mclapply(dyad_sleep_diffs,
#get_date_differences,
#mc.cores = getOption("mc.cores", 4L))
# only run once
#saveRDS(date_diffs_sleep, "date_diffs_sleep.rds")
# apply function to steps data
#date_diffs_steps <- lapply(dyad_steps_diffs, get_date_differences)
# only run once
#saveRDS(date_diffs_steps, "date_diffs_steps.rds")
# collapse all *sleep* list elements into a single object
###
# load data objects created in commented out section
date_diffs_sleep <- readRDS("date_diffs_sleep.rds")
date_diffs_steps <- readRDS("date_diffs_steps.rds")
# first make tibble
date_diffs_sleep <- lapply(date_diffs_sleep, function(x){
x %>%
as_tibble() %>%
rename(interval = value)
})
# next, merge all elements into a single object
date_diffs_sleep_t <- bind_rows(date_diffs_sleep)
# collapse all *step* list elements into a single object
# first make tibble
date_diffs_steps <- lapply(date_diffs_steps, function(x){
x %>%
as_tibble() %>%
rename(interval = value)
})
# next, merge all elements into a single object
date_diffs_steps_t <- bind_rows(date_diffs_steps)
# histogram of sleep intervals
date_diffs_sleep_t %>%
ggplot(aes(x = interval)) +
geom_histogram(show.legend = FALSE) +
labs(main = "Distribution of interval between every dyad observation",
subtitle= "Only observations with no missing data",
x = "Interval Length",
y = "Number of Occurences")
# how many total intervals? use to get proportion
# dim(date_diffs_sleep_t)
# 100076296, 1
# look at density, no longer visualizing 1 (but keeping in proportions)
date_diffs_sleep_t %>%
ggplot(aes(x = interval)) +
geom_density(show.legend = FALSE) +
#coord_cartesian(xlim=c(2, max(date_diffs_sleep_t$interval))) +
#coord_cartesian(xlim=c(2, 200)) +
coord_cartesian(xlim=c(1, 10)) +
labs(title = "Distribution of interval between every dyad observation",
subtitle= "Note: only observations with no missing data",
x = "Interval Length",
y = "Number of Occurences")
# get proportion of cases with intervals from 2-4
prop_intervals <- sapply(seq(from = 2, to = 5, by = 1),
function(x){
date_diffs_sleep_t %>%
filter(interval < x) %>%
summarise(n_filtered = n(),
prop_filtered = n_filtered / 100076296,
days_interval = x-1)
})
# print
prop_intervals
# import on laptop
sleep_filtered <- readRDS("sleep_filtered.rds")
steps_filtered <- readRDS("steps_filtered.rds")
sleep_filtered[[1]]
dyad_sleep_diffs[[1]]
View(dyad_sleep_diffs[[1]])
# race in a double
# race in a double
fitbit_data
# convert to tibble
fitbit_data <- as_tibble(fitbit_data)
#####
##### load and clean daily fitbit data for nethealth project
#####
# call libraries
library(readstata13)
library(dplyr)
library(here)
library(lubridate)
# import data
fitbit_data <- read.dta13(file = here::here("dailyfitbit.dta"))
# checkout warnings to isolate specific variables
# convert to tibble
fitbit_data <- as_tibble(fitbit_data)
# which variables in object
names(fitbit_data)
# class of each variable
glimpse(fitbit_data)
# make datadate a proper date format
fitbit_data$datadate <- ymd(fitbit_data$datadate)
# number of unique participants
n_distinct(fitbit_data$NetIdEmail)
# number of unique daily participant-observation units
n_distinct(fitbit_data$idstudy) # 429071
# earliest and latest dates
fitbit_data %>%
summarise(earliest_date = min(datadate),
latest_date = max(datadate))
# gender is an integer
class(fitbit_data$gender)
# race in a double
View(fitbit_data)
View(is.na(fitbit_data))
fitbit_data %>% filter(is.na(steps)) %>% View
wordstoremove <- c("ai", "computing", "ulitzer", "ibm", "privacy", "cognitive")
(dat <- read.table(header = TRUE, text = 'id text time username
1 "ai and x" 10 "me"
2 "and computing" 5 "you"
3 "nothing" 15 "everyone"
4 "ibm privacy" 0 "know"'))
(dat1 <- as.data.frame(sapply(dat, function(x)
gsub(paste(wordstoremove, collapse = '|'), '', x))))
dat <- dat %>%
mutate(text = str_remove_all(text, regex(str_c("\\b",wordstoremove, "\\b", collapse = '|'), ignore_case = T)))
dat <- dat %>%
mutate(text = stringr::str_remove_all(text, regex(str_c("\\b",wordstoremove, "\\b", collapse = '|'), ignore_case = T)))
library(stringr)
dat <- dat %>%
mutate(text = str_remove_all(text, regex(str_c("\\b",wordstoremove, "\\b", collapse = '|'), ignore_case = T)))
dat
class(wordstoremove)
library(lubridate)
test_seq <- seq(from = ymd("2018-10-01"), to = ymd("2018-10-20", by "days"))
test_seq <- seq(from = ymd("2018-10-01"), to = ymd("2018-10-20", by = "days"))
dyad_sleep_diffs[[1]]
head(ymd(dyad_sleep_diffs[[1]]$datadate))
test_seq <- seq(from = ymd("2018-10-01"), to = ymd("2018-10-20", by = "1 day"))
test_seq <- seq(from = ymd("2018-10-01"), to = ymd("2018-10-20"), by = "days")
test_seq

---
title: "Missing Data - Part 2"
author: "Brandon Sepulvado"
date: "12/10/2018"
output: word_document
---

```{r load_packages, message=FALSE, warning=FALSE, include=FALSE}
library(dplyr)
library(lubridate)
library(here)
library(ggplot2)
library(tibble)
library(parallel)
```


# Problem
In the last missing data report, I identified two key issues with missing data: (1) the number of missing observations for each dyad, (2) the number of total observations for each dyad, and (3) the length of time between each dyadic observation. Each of these posed challenges to imputation and/or analysis, but we decided first to remove breaks.

# Removing breaks

## Load break data
The following line creates a data frame (rather, a tibble) containing the various breaks as stated in the academic calendars from the 2015-2016 academic year through the end of the 2017-2018 academic year. I do not include the current one because I will remove everything past the end of Spring 2018. I will do so because the data used for the current analyses end in September 2018, and, as such, is incomplete. 
```{r get_break_dates}
source(here("academic_cal_breaks.R"))
dates_to_remove
```
The script called produces `dates_to_remove`, a tibble for which each row is a date that should be removed from dyadic observations and which contains only a single date column. Note that, because each row is a date, there are not ranges to remove. 

## Load dyad activity data
The next step is to remove these dates from each dyad's observations contained in the following two objects.
```{r load_dyad_asleep_steps}
# load sleep data
dyad_sleep_diffs <- readRDS(here("dyad_sleep_diffs.rds"))

# load steps data
dyad_steps_diffs <- readRDS(here("dyad_steps_diffs.rds"))

# show data example
dyad_sleep_diffs[[1]]
```
To reiterate basic information from the last report, these objects are lists with lengths equal to the number of dyads (~390,000) who overlapped in the study at any point.[^1] Each element contains a data frame (tibble) with five columns and a number of rows that varies according to the number of overlapping study days. The columns are `datadate`, `diff` (the difference for a given day in the focal activity count), `dyad_id` (the unique identifier for a dyad), `node1`, and `node2` (the unique nodal identifiers).

[^1]: Overlap, as defined here, occurs on days for which both individuals have *some* form of observed fitbit data; this data does not necessarily have to be one of the focal activities under investigation (e.g., sleep or steps). These objects were created from the dailyfitbit.dta file and end in September 2018; see the data_import_clean.R file for more detailed information.

## Remove break dates from activity data
Now, I will remove the break dates from the dyad lists.
```{r remove_break_dates}
# remove for sleep data
dyad_sleep_diffs_filtered <- lapply(dyad_sleep_diffs, function(x){
  x <- x %>% 
    filter(!datadate %in% dates_to_remove$date)
  
  return(x)
})

# remove for steps
dyad_steps_diffs_filtered <- lapply(dyad_steps_diffs, function(x){
  x <- x %>% 
    filter(!datadate %in% dates_to_remove$date)
  
  return(x)
})
```

```{r save_filtered_objects, eval=FALSE, include=FALSE}
saveRDS(dyad_sleep_diffs_filtered, file = here("dyad_sleep_diffs_filtered.rds"))
saveRDS(dyad_steps_diffs_filtered, file = here("dyad_steps_diffs_filtered.rds"))

```



# Existing problems

## Number of total observations
I will start by addressing the second key issue: the total number of non-missing observations. Basically, we do not want to keep a case if it has only a few observations, but it is difficult to identify a priori what should be the threshold.

This code plots histograms of the number of non-missing dyadic bservations for sleep and steps.
```{r nonmissing_sleep_steps}
# get number of non_missing days for dyads
nonmissing_steps_days <- sapply(dyad_steps_diffs_filtered, 
                                function(x) sum(!is.na(x['diff'])))
nonmissing_sleep_days <- sapply(dyad_sleep_diffs_filtered, 
                                function(x) sum(!is.na(x['diff'])))

# make tibble to be able to facet histogram
steps_nonmiss_t <- as_tibble(nonmissing_steps_days) %>% 
  rename(n_days = value) %>% 
  mutate(activity = "steps")
sleep_nonmiss_t <- as_tibble(nonmissing_sleep_days) %>% 
  rename(n_days = value) %>% 
  mutate(activity = "sleep")
nonmissing_combined <- bind_rows(steps_nonmiss_t,
                                   sleep_nonmiss_t)

# get mean for missing proportion types for histograms below
mean_steps <- mean(steps_nonmiss_t$n_days, na.rm = TRUE)
mean_sleep <- mean(sleep_nonmiss_t$n_days, na.rm = TRUE)

# get median for missing proportion types 
# get mean for missing proportion types for histograms below
median_steps <- median(steps_nonmiss_t$n_days, na.rm = TRUE)
median_sleep <- median(sleep_nonmiss_t$n_days, na.rm = TRUE)

# plot histogram faceted
nonmissing_combined %>% 
  ggplot(aes(x = n_days, fill = as.factor(activity))) +
  geom_histogram(alpha = 0.5) +
  facet_wrap(~as.factor(activity)) +
  labs(title = "Distribution of non-missing days per dyad",
       x = "Number of Days",
       y = "Count") +
  scale_fill_discrete(name = "Type of activity") +
  geom_vline(data=filter(nonmissing_combined, as.factor(activity)=="steps"),
             aes(xintercept=mean_steps), linetype = "dashed", colour="black") +
  geom_vline(data=filter(nonmissing_combined, as.factor(activity)=="sleep"),
             aes(xintercept=mean_sleep), linetype = "dashed", colour="black") +
  geom_vline(data=filter(nonmissing_combined, as.factor(activity)=="steps"),
             aes(xintercept=median_steps), linetype = "solid", colour="black") +
  geom_vline(data=filter(nonmissing_combined, as.factor(activity)=="sleep"),
             aes(xintercept=median_sleep), linetype = "solid", colour="black")
```
These two histograms seem promising. The solid vertical lines represent the medians (sleep: `r median_sleep`, steps: `r median_steps`), while the dashed lines represent the means (sleep: `r mean_sleep`. steps: `r mean_steps`). 50% of dyads have at least 172 days of observations.

But, what is the minimum number of observations we want? The following code presents a series of thresholds, starting at one week and ending at 24 weeks (the highest number of whole weeks under the median).
```{r observed_threshold}
# create weekly threshold, in number of days
week_threshold <- tibble(threshold = seq(from = 7,
                                         to = 168,
                                         by = 7))

# apply to sleep
num_obs_sleep <- lapply(week_threshold$threshold, function(x){
 prop_above_thresh <- nonmissing_combined %>% 
   filter(activity == "sleep") %>% 
   filter(n_days >= x) %>% 
   summarise(proportion = n() / 390000)
 }) %>%
  bind_rows() %>% 
  mutate(threshold = seq(from = 7, 
                         to = 168, 
                         by = 7),
         activity = "sleep")

# apply to steps
num_obs_steps <- lapply(week_threshold$threshold, function(x){
 prop_above_thresh <- nonmissing_combined %>% 
   filter(activity == "steps") %>% 
   filter(n_days >= x) %>% 
   summarise(proportion = n() / 390000)
 }) %>%
  bind_rows() %>% 
  mutate(threshold = seq(from = 7, 
                         to = 168, 
                         by = 7),
         activity = "steps")

# combine into single object
num_obs_combined <- bind_rows(num_obs_steps, num_obs_sleep)

# make type a factor
num_obs_combined$activity <- as.factor(num_obs_combined$activity)

# graph
num_obs_combined %>% 
  ggplot(aes(x = threshold, y = proportion)) +
  geom_line(aes(linetype = activity, colour = activity)) +
  geom_point() +
  labs(title = "Proportion of dyads versus missing data thresholds",
       x = "Minimum number of non-missing observations",
       y = "Proportion of dyads remaining")
```
This visualization illustrates how many dyads we lose at different numbers of minimum observations. The points of the line begin at seven and then represent a multiple of seven until 168, which is the last multiple of seven below the median number of dyadic observations. Unfortunately, there is no natural break in the line, but I recommend a *14 day minimum* because it is the lowest number that would enable us to identify weekly seasonality (that is, if there exists trends based on specific days of the week). We would retain roughly 85% of dyads.

## Missing data
The number of NAs was noted as one of two key problems. The following code visualizes the number and proportion of daily observations that have NA values *for each dyad*.

```{r missing_data, message=FALSE, warning=FALSE}
# how many dyads have missing data, meaning both in study at same time
# but one person (at least) has NA for day on given measure
missing_steps_count <- sapply(dyad_steps_diffs_filtered, function(x) sum(is.na(x['diff'])))
missing_sleep_count <- sapply(dyad_sleep_diffs_filtered, function(x) sum(is.na(x['diff'])))

# get proportion of dyad's common dates with missing data
missing_steps_prop <- sapply(dyad_steps_diffs_filtered, function(x) sum(is.na(x['diff'])) / nrow(x))
missing_sleep_prop <- sapply(dyad_sleep_diffs_filtered, function(x) sum(is.na(x['diff'])) / nrow(x))

### counts

# make tibble to be able to facet histogram
steps_miss_count_t <- as_tibble(missing_steps_count) %>% 
  rename(count = value) %>% 
  mutate(activity = "steps")
sleep_miss_count_t <- as_tibble(missing_sleep_count) %>% 
  rename(count = value) %>% 
  mutate(activity = "sleep")
missing_count_combined <- bind_rows(steps_miss_count_t,
                                   sleep_miss_count_t)

# get mean for missing proportion types for histograms below
mean_steps_count <- mean(steps_miss_count_t$count, na.rm = TRUE)
mean_sleep_count <- mean(sleep_miss_count_t$count, na.rm = TRUE)

# get median for missing proportion types 
# get mean for missing proportion types for histograms below
median_steps_count <- median(steps_miss_count_t$count, na.rm = TRUE)
median_sleep_count <- median(sleep_miss_count_t$count, na.rm = TRUE)

# plot histogram faceted
missing_count_combined %>% 
  ggplot(aes(x = count, fill = as.factor(activity))) +
  geom_histogram(alpha = 0.5) +
  facet_wrap(~as.factor(activity)) +
  labs(title = "Number of NAs for each dyad",
       x = "Number of NA Observations",
       y = "Number of Dyads") +
  scale_fill_discrete(name = "Type of activity") +
  geom_vline(data=filter(missing_count_combined, as.factor(activity)=="steps"),
             aes(xintercept=mean_steps_count), 
             linetype = "dashed", colour="black") +
  geom_vline(data=filter(missing_count_combined, as.factor(activity)=="sleep"),
             aes(xintercept=mean_sleep_count),
             linetype = "dashed", colour="black") +
  geom_vline(data=filter(missing_count_combined, as.factor(activity)=="steps"),
             aes(xintercept=median_steps_count),
             linetype = "solid", colour="black") +
  geom_vline(data=filter(missing_count_combined, as.factor(activity)=="sleep"),
             aes(xintercept=median_sleep_count),
             linetype = "solid", colour="black")


### proportions

# make tibble to be able to facet histogram
steps_miss_prop_t <- as_tibble(missing_steps_prop) %>% 
  rename(proportion = value) %>% 
  mutate(activity = "steps")
sleep_miss_prop_t <- as_tibble(missing_sleep_prop) %>% 
  rename(proportion = value) %>% 
  mutate(activity = "sleep")
missing_prop_combined <- bind_rows(steps_miss_prop_t,
                                   sleep_miss_prop_t)

# get mean for missing proportion types for histograms below
mean_steps_prop <- mean(steps_miss_prop_t$proportion, na.rm = TRUE)
mean_sleep_prop <- mean(sleep_miss_prop_t$proportion, na.rm = TRUE)

# get median for missing proportion types 
# get mean for missing proportion types for histograms below
median_steps_prop <- median(steps_miss_prop_t$proportion, na.rm = TRUE)
median_sleep_prop <- median(sleep_miss_prop_t$proportion, na.rm = TRUE)

# plot histogram faceted
missing_prop_combined %>% 
  ggplot(aes(x = proportion, fill = as.factor(activity))) +
  geom_histogram(alpha = 0.5) +
  facet_wrap(~as.factor(activity)) +
  labs(title = "Proportion of daily data missing for each dyad",
       x = "Proportion",
       y = "Count") +
  scale_fill_discrete(name = "Type of activity") +
  geom_vline(data=filter(missing_prop_combined, as.factor(activity)=="steps"),
             aes(xintercept=mean_steps_prop), 
             linetype = "dashed", colour="black") +
  geom_vline(data=filter(missing_prop_combined, as.factor(activity)=="sleep"),
             aes(xintercept=mean_sleep_prop),
             linetype = "dashed", colour="black") +
  geom_vline(data=filter(missing_prop_combined, as.factor(activity)=="steps"),
             aes(xintercept=median_steps_prop),
             linetype = "solid", colour="black") +
  geom_vline(data=filter(missing_prop_combined, as.factor(activity)=="sleep"),
             aes(xintercept=median_sleep_prop),
             linetype = "solid", colour="black")
```
The preceeding code outputs two visualizations, each faceted by the type of activity (although they are almost identical). The first visualization shows the *number* of NA observations for each dyad, and the second shows the *proportion of each dyad's observations* that are NA. Examining the first set of two histograms, it is evident that the distribution of dyadic number of NAs is very skewed to the right. The median (sleep: `r median_sleep_count`, steps: `r median_steps_count`) is represented by the solid black vertical line, and the mean (sleep: `r mean_sleep_count`, steps: `r mean_steps_count`) is represented by the dashed line. 

The second set of histograms presents the proportion of each dyad's observations that are missing. As before, the median (sleep: `r median_sleep_prop`, steps: `r median_steps_prop`) is represented by the solid black vertical line, and the mean (sleep: `r mean_sleep_prop`, steps: `r mean_steps_prop`) is represented by the dashed line. The results indicate that, while the majority of dyads have at least half of their data, most also have a non-negligible number of NAs. 

In order to provide a bit more fine-grained insight into the number of cases we would retain at different missing data proportion thresholds, I next provide a line graph similar to the one in the previous section.
```{r missing_prop_thresholds}
# create thresholds
prop_threshold <- tibble(threshold = seq(from = .05,
                                         to = .4,
                                         by = .05))

# apply to sleep
sleep_miss_prop_thresh <- lapply(prop_threshold$threshold, function(x){
 prop_above_thresh <- missing_prop_combined %>% 
   filter(activity == "sleep") %>% 
   filter(proportion >= x) %>% 
   summarise(proportion_dyads = n() / 390000)
 }) %>%
  bind_rows() %>% 
  mutate(threshold = seq(from = .05, 
                         to = .40, 
                         by = .05),
         activity = "sleep")

# apply to steps
steps_miss_prop_thresh <- lapply(prop_threshold$threshold, function(x){
 prop_above_thresh <- missing_prop_combined %>% 
   filter(activity == "steps") %>% 
   filter(proportion >= x) %>% 
   summarise(proportion_dyads = n() / 390000)
 }) %>%
  bind_rows() %>% 
  mutate(threshold = seq(from = .05, 
                         to = .40, 
                         by = .05),
         activity = "steps")

# combine into single object
num_obs_combined <- bind_rows(sleep_miss_prop_thresh, steps_miss_prop_thresh)

# make type a factor
num_obs_combined$activity <- as.factor(num_obs_combined$activity)

# graph
num_obs_combined %>% 
  ggplot(aes(x = threshold, y = proportion_dyads)) +
  geom_line(aes(linetype = activity, colour = activity)) +
  geom_point() +
  labs(title = "Proportion of dyads versus missing data thresholds (proportion)",
       x = "Minimum proportion of non-missing dyadic observations",
       y = "Proportion of dyads remaining")
```



## Gaps in observation dates (non-consecutive daily observations)
The next issue consists in the duration of time between observations because imputing missing values quickly becomes arbitrary. In the following code chunk, I get the differences in observations for each dyad, which means there will be one fewer row in this output than there are dyadic observation. I include this code for illustrtaive purposes, but I do not run it because it requires the CRC clusters. 
```{r get_date_diffs, eval=FALSE}
# function to get interval vector of date differences
get_date_differences <- function(data, format = "day"){
  
  temp <- data %>% 
    filter(!is.na(diff)) %>% 
    select(datadate, dyad_id)
  
  temp <- ymd(temp$datadate)
  
  diffs <- temp %>% 
    int_diff() %>% 
    as.duration() %>%
    as.numeric() %>% 
    as_tibble() %>% 
    mutate(dyad_id = unique(data$dyad_id)) %>% 
    rename(diff = value)
  
  if (format == "day") {
    return(mutate(diffs, diff = diff / 86400))
    #return(diffs / 86400)
  } else if (format == "seconds") {
    return(diffs)
  } else {
    stop("You have chosen an unsupported date format!")
  }
}

# apply to sleep
sleep_date_diffs <- mclapply(dyad_sleep_diffs_filtered, function(x){
  # get difference vector
  diff_tibble <- get_date_differences(x)

  # return outptu
  return(diff_tibble)
  }, mc.cores = getOption("mc.cores", 4L)
)

# apply to steps
steps_date_diffs <- mclapply(dyad_steps_diffs_filtered, function(x){
  # get difference vector
  diff_tibble <- get_date_differences(x)

  # return output
  return(diff_tibble)
  }, mc.cores = getOption("mc.cores", 4L)
)

# put in one tibble
sleep_steps_date_diffs_t <- bind_rows(sleep_date_diffs, steps_date_diffs)
```

This code will load the output from the previous chunk.
```{r load_crc_output}
sleep_date_diffs <- readRDS(here("sleep_date_diffs.rds"))
sleep_steps_diffs <- readRDS(here("steps_date_diffs.rds"))
sleep_steps_date_diffs_t <- readRDS(here("sleep_steps_date_diffs_t.rds"))
```
The first two objects are lists with a length of 390,000 (the number of dyads), and the third object is a data frame/tibble that concatenates each element within both lists and then the two lists themselves. It has 175,202,434 rows and two columns (the difference between two observations for a dyad and the associated dyad id). Here are two examples.
```{r crc_output_examples}
head(sleep_date_diffs[[1]], 10)
head(sleep_steps_date_diffs_t, 10)
```

Now, let's visualize the distribution of the intervals between dyadic observations.
```{r}
sleep_date_diffs %>% 
  bind_rows() %>% 
  ggplot(aes(x = diff)) +
  geom_density(show.legend = FALSE) +
  coord_cartesian(xlim = c(0, 15))
```
It seems that the natural break in the missing data has not changed from before filtering out the breaks. *Do we want to keep this at four or lower it?*

The following code examines how many *dyads* we lose when we filter at 2, 3, and 4 day intervals between observations. 
```{r}
sapply(c(2,3,4), function(x){
  sleep_steps_date_diffs_t %>% 
    filter(diff <= x) %>% 
    summarise(n_distinct(dyad_id) / 390000)
})

sleep_steps_date_diffs_t %>% 
  summarise(prop_dyads_2 = filter(sleep_steps_date_diffs_t,
                                  diff <= 2) %>% 
                            summarise(n_distinct(dyad_id) / 390000))



prop_intervals <- sapply(seq(from = 2, to = 4, by = 1),
                         function(x){
                           sleep_date_diffs %>%
                             bind_rows() %>% 
                            filter(diff <= x) %>% 
                            summarise(n_dyads_filtered = n_distinct(dyad_id),
                                      prop_filtered = n_dyads_filtered / 345976,
                                      interval = x)
                         })


```







# New problem
Now that break dates have been removed, a new consideration arises: how do we align the last day before a removed period and the first day after it? If we are going to retain the ability to discern seasonality, then we must have equisdistant intervals between each observation. 

One potential solution is to resume a time series starting on the day of the week that follows the last date before a deleted period. Doing so might throw out usable data, or it might introduce bias due to a transitionary period between return from break and normal activities. 

Remove before first day of classes? When is first day that everyone would have observations? Does not work because new waves; plus, only shows up in these lists if both dyads have data. 
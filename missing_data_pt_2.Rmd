---
title: "Missing Data - Part 2"
author: "Brandon Sepulvado"
date: "12/10/2018"
output: word_document
---

```{r load_packages, message=FALSE, warning=FALSE, include=FALSE}
library(dplyr)
library(lubridate)
library(here)
library(ggplot2)
library(tibble)
```


# Problem
In the last missing data report, I identified two key issues with missing data: (1) the number of missing observations for each dyad, (2) the number of total observations for each dyad, and (3) the length of time between each dyadic observation. Each of these posed challenges to imputation and/or analysis, but we decided first to remove breaks.

# Removing breaks

## Load break data
The following line creates a data frame (rather, a tibble) containing the various breaks as stated in the academic calendars from the 2015-2016 academic year through the end of the 2017-2018 academic year. I do not include the current one because I will remove everything past the end of Spring 2018. I will do so because the data used for the current analyses end in September 2018, and, as such, is incomplete. 
```{r get_break_dates}
source(here("academic_cal_breaks.R"))
dates_to_remove
```
The script called produces `dates_to_remove`, a tibble for which each row is a date that should be removed from dyadic observations and which contains only a single date column. Note that, because each row is a date, there are not ranges to remove. 

## Load dyad activity data
The next step is to remove these dates from each dyad's observations contained in the following two objects.
```{r load_dyad_asleep_steps}
# load sleep data
dyad_sleep_diffs <- readRDS(here("dyad_sleep_diffs.rds"))

# load steps data
dyad_steps_diffs <- readRDS(here("dyad_steps_diffs.rds"))

# show data example
dyad_sleep_diffs[[1]]
```
To reiterate basic information from the last report, these objects are lists with lengths equal to the number of dyads (~390,000) who overlapped in the study at any point.[^1] Each element contains a data frame (tibble) with five columns and a number of rows that varies according to the number of overlapping study days. The columns are `datadate`, `diff` (the difference for a given day in the focal activity count), `dyad_id` (the unique identifier for a dyad), `node1`, and `node2` (the unique nodal identifiers).

[^1]: Overlap, as defined here, occurs on days for which both individuals have *some* form of observed fitbit data; this data does not necessarily have to be one of the focal activities under investigation (e.g., sleep or steps). These objects were created from the dailyfitbit.dta file and end in September 2018; see the data_import_clean.R file for more detailed information.

## Remove break dates from activity data
Now, I will remove the break dates from the dyad lists
```{r remove_break_dates}
# remove for sleep data
dyad_sleep_diffs_filtered <- lapply(dyad_sleep_diffs, function(x){
  x <- x %>% 
    filter(!datadate %in% dates_to_remove$date)
  
  return(x)
})

# remove for steps
dyad_steps_diffs_filtered <- lapply(dyad_steps_diffs, function(x){
  x <- x %>% 
    filter(!datadate %in% dates_to_remove$date)
  
  return(x)
})
```


# Existing problems

## Number of total observations
I will start by addressing the second key issue: the total number of non-missing observations. Basically, we do not want to keep a case if it has only a few observations, but it is difficult to identify a priori what should be the threshold.

This code plots histograms of the number of non-missing dyadic bservations for sleep and steps.
```{r nonmissing_sleep_steps}
# get number of non_missing days for dyads
nonmissing_steps_days <- sapply(dyad_steps_diffs_filtered, 
                                function(x) sum(!is.na(x['diff'])))
nonmissing_sleep_days <- sapply(dyad_sleep_diffs_filtered, 
                                function(x) sum(!is.na(x['diff'])))

# make tibble to be able to facet histogram
steps_nonmiss_t <- as_tibble(nonmissing_steps_days) %>% 
  rename(n_days = value) %>% 
  mutate(activity = "steps")
sleep_nonmiss_t <- as_tibble(nonmissing_sleep_days) %>% 
  rename(n_days = value) %>% 
  mutate(activity = "sleep")
nonmissing_combined <- bind_rows(steps_nonmiss_t,
                                   sleep_nonmiss_t)

# get mean for missing proportion types for histograms below
mean_steps <- mean(steps_nonmiss_t$n_days, na.rm = TRUE)
mean_sleep <- mean(sleep_nonmiss_t$n_days, na.rm = TRUE)

# get median for missing proportion types 
# get mean for missing proportion types for histograms below
median_steps <- median(steps_nonmiss_t$n_days, na.rm = TRUE)
median_sleep <- median(sleep_nonmiss_t$n_days, na.rm = TRUE)

# plot histogram faceted
nonmissing_combined %>% 
  ggplot(aes(x = n_days, fill = as.factor(activity))) +
  geom_histogram(alpha = 0.5) +
  facet_wrap(~as.factor(activity)) +
  labs(title = "Distribution of non-missing days per dyad",
       x = "Number of Days",
       y = "Count") +
  scale_fill_discrete(name = "Type of activity") +
  geom_vline(data=filter(nonmissing_combined, as.factor(activity)=="steps"),
             aes(xintercept=mean_steps), linetype = "dashed", colour="black") +
  geom_vline(data=filter(nonmissing_combined, as.factor(activity)=="sleep"),
             aes(xintercept=mean_sleep), linetype = "dashed", colour="black") +
  geom_vline(data=filter(nonmissing_combined, as.factor(activity)=="steps"),
             aes(xintercept=median_steps), linetype = "solid", colour="black") +
  geom_vline(data=filter(nonmissing_combined, as.factor(activity)=="sleep"),
             aes(xintercept=median_sleep), linetype = "solid", colour="black")
```
These two histograms seem promising. The solid vertical lines represent the medians (sleep: `r median_sleep`, steps: `r median_steps`), while the dashed lines represent the means (sleep: `r mean_sleep`. steps: `r mean_steps`). 50% of dyads have at least 172 days of observations.

But, what is the minimum number of observations we want? The following code presents a series of thresholds, starting at one week and ending at 24 weeks (the highest number of whole weeks under the median).
```{r observed_threshold}
# create weekly threshold, in number of days
week_threshold <- tibble(threshold = seq(from = 7,
                                         to = 168,
                                         by = 7))

# apply to sleep
num_obs_sleep <- lapply(week_threshold$threshold, function(x){
 prop_above_thresh <- nonmissing_combined %>% 
   filter(activity == "sleep") %>% 
   filter(n_days >= x) %>% 
   summarise(proportion = n() / 390000)
 }) %>%
  bind_rows() %>% 
  mutate(threshold = seq(from = 7, 
                         to = 168, 
                         by = 7),
         activity = "sleep")

# apply to steps
num_obs_steps <- lapply(week_threshold$threshold, function(x){
 prop_above_thresh <- nonmissing_combined %>% 
   filter(activity == "steps") %>% 
   filter(n_days >= x) %>% 
   summarise(proportion = n() / 390000)
 }) %>%
  bind_rows() %>% 
  mutate(threshold = seq(from = 7, 
                         to = 168, 
                         by = 7),
         activity = "steps")

# combine into single object
num_obs_combined <- bind_rows(num_obs_steps, num_obs_sleep)

# make type a factor
num_obs_combined$activity <- as.factor(num_obs_combined$activity)

# graph
num_obs_combined %>% 
  ggplot(aes(x = threshold, y = proportion)) +
  geom_line(aes(linetype = activity, colour = activity)) +
  geom_point() +
  labs(title = "Proportion of dyads versus missing data thresholds",
       x = "Minimum number of non-missing observations",
       y = "Proportion of dyads remaining")
```


I remove elements now to simply the data pruning process in the next step. For example, I will identify in the next step the overall levels of missing observations as well as *a threshold of acceptability*, and, if we were to retain cases with too few observations in this section, waiting for removal until the next stage might allow the cases to be retained that are near the acceptable threshold of number of observations but would only fall above the cutoff if observations with NA were included. This number of course would likely not be too large because the dyad would have to be close to threshold for total number of observations (just below) and also within the acceptable limit for number of missing observations. 

## Missing data
The number of NAs was noted as one of two key problems. The following code visualizes the number and proportion of daily observations that have NA values *for each dyad*.

```{r missing_data, message=FALSE, warning=FALSE}
# how many dyads have missing data, meaning both in study at same time
# but one person (at least) has NA for day on given measure
missing_steps_count <- sapply(dyad_steps_diffs_filtered, function(x) sum(is.na(x['diff'])))
missing_sleep_count <- sapply(dyad_sleep_diffs_filtered, function(x) sum(is.na(x['diff'])))

# get proportion of dyad's common dates with missing data
missing_steps_prop <- sapply(dyad_steps_diffs_filtered, function(x) sum(is.na(x['diff'])) / nrow(x))
missing_sleep_prop <- sapply(dyad_sleep_diffs_filtered, function(x) sum(is.na(x['diff'])) / nrow(x))

### counts

# make tibble to be able to facet histogram
steps_miss_count_t <- as_tibble(missing_steps_count) %>% 
  rename(count = value) %>% 
  mutate(activity = "steps")
sleep_miss_count_t <- as_tibble(missing_sleep_count) %>% 
  rename(count = value) %>% 
  mutate(activity = "sleep")
missing_count_combined <- bind_rows(steps_miss_count_t,
                                   sleep_miss_count_t)

# get mean for missing proportion types for histograms below
mean_steps_count <- mean(steps_miss_count_t$count, na.rm = TRUE)
mean_sleep_count <- mean(sleep_miss_count_t$count, na.rm = TRUE)

# get median for missing proportion types 
# get mean for missing proportion types for histograms below
median_steps_count <- median(steps_miss_count_t$count, na.rm = TRUE)
median_sleep_count <- median(sleep_miss_count_t$count, na.rm = TRUE)

# plot histogram faceted
missing_count_combined %>% 
  ggplot(aes(x = count, fill = as.factor(activity))) +
  geom_histogram(alpha = 0.5) +
  facet_wrap(~as.factor(activity)) +
  labs(title = "Number of NAs for each dyad",
       x = "Number of NA Observations",
       y = "Number of Dyads") +
  scale_fill_discrete(name = "Type of activity") +
  geom_vline(data=filter(missing_count_combined, as.factor(activity)=="steps"),
             aes(xintercept=mean_steps_count), 
             linetype = "dashed", colour="black") +
  geom_vline(data=filter(missing_count_combined, as.factor(activity)=="sleep"),
             aes(xintercept=mean_sleep_count),
             linetype = "dashed", colour="black") +
  geom_vline(data=filter(missing_count_combined, as.factor(activity)=="steps"),
             aes(xintercept=median_steps_count),
             linetype = "solid", colour="black") +
  geom_vline(data=filter(missing_count_combined, as.factor(activity)=="sleep"),
             aes(xintercept=median_sleep_count),
             linetype = "solid", colour="black")


### proportions

# make tibble to be able to facet histogram
steps_miss_prop_t <- as_tibble(missing_steps_prop) %>% 
  rename(proportion = value) %>% 
  mutate(activity = "steps")
sleep_miss_prop_t <- as_tibble(missing_sleep_prop) %>% 
  rename(proportion = value) %>% 
  mutate(activity = "sleep")
missing_prop_combined <- bind_rows(steps_miss_prop_t,
                                   sleep_miss_prop_t)

# get mean for missing proportion types for histograms below
mean_steps_prop <- mean(steps_miss_prop_t$proportion, na.rm = TRUE)
mean_sleep_prop <- mean(sleep_miss_prop_t$proportion, na.rm = TRUE)

# get median for missing proportion types 
# get mean for missing proportion types for histograms below
median_steps_prop <- median(steps_miss_prop_t$proportion, na.rm = TRUE)
median_sleep_prop <- median(sleep_miss_prop_t$proportion, na.rm = TRUE)

# plot histogram faceted
missing_prop_combined %>% 
  ggplot(aes(x = proportion, fill = as.factor(activity))) +
  geom_histogram(alpha = 0.5) +
  facet_wrap(~as.factor(activity)) +
  labs(title = "Proportion of day data missing for each dyad",
       x = "Proportion",
       y = "Count") +
  scale_fill_discrete(name = "Type of activity") +
  geom_vline(data=filter(missing_prop_combined, as.factor(activity)=="steps"),
             aes(xintercept=mean_steps_prop), 
             linetype = "dashed", colour="black") +
  geom_vline(data=filter(missing_prop_combined, as.factor(activity)=="sleep"),
             aes(xintercept=mean_sleep_prop),
             linetype = "dashed", colour="black") +
  geom_vline(data=filter(missing_prop_combined, as.factor(activity)=="steps"),
             aes(xintercept=median_steps_prop),
             linetype = "solid", colour="black") +
  geom_vline(data=filter(missing_prop_combined, as.factor(activity)=="sleep"),
             aes(xintercept=median_sleep_prop),
             linetype = "solid", colour="black")
```
The preceeding code outputs two visualizations, each faceted by the type of activity (although they are almost identical). The first visualization shows the *number* of NA observations for each dyad, and the second shows the *proportion of each dyad's observations* that are NA. Examining the first set of two histograms, it is evident that the distribution of dyadic number of NAs is very skewed to the right. The median (sleep: `r median_sleep_count`, steps: `r median_steps_count`) is represented by the solid black vertical line, and the mean (sleep: `r mean_sleep_count`, steps: `r mean_steps_count`) is represented by the dashed line. 

The second set of histograms presents the proportion of each dyad's observations that are missing. As before, the median (sleep: `r median_sleep_prop`, steps: `r median_steps_prop`) is represented by the solid black vertical line, and the mean (sleep: `r mean_sleep_prop`, steps: `r mean_steps_prop`) is represented by the dashed line. The results indicate that, while the majority of dyads have at least half of their data, most also have a non-negligible number of NAs. 


## Gaps in observation dates (non-consecutive daily observations)



# New problem
Now that break dates have been removed, a new consideration arises: how do we align the last day before a removed period and the first day after it? If we are going to retain the ability to discern seasonality, then we must have equisdistant intervals between each observation. 

One potential solution is to resume a time series starting on the day of the week that follows the last date before a deleted period. Doing so might throw out usable data, or it might introduce bias due to a transitionary period between return from break and normal activities. 

Remove before first day of classes? When is first day that everyone would have observations? Does not work because new waves; plus, only shows up in these lists if both dyads have data. 